// Generated by CoffeeScript 1.4.0
var Records, Schema,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

Schema = require('./Schema');

/*

Records access and manipulation
===============================

Implement object based storage with indexing support.   

Identifier
----------

Auto generated identifiers are incremented integers. The next identifier is obtained from
a key named as `{s.db}:{s.name}_incr`. All the identifiers are stored as a Redis set in 
a key named as `{s.db}:{s.name}_#{identifier}`.   

Data
----

Records data is stored as a single hash named as `{s.db}:{s.name}:{idenfitier}`. The hash
keys map to the record properties and the hash value map to the values associated with
each properties.   

Regular indexes
---------------

Regular index are stored inside multiple sets, named as
`{s.db}:{s.name}_{property}:{value}`. There is one key for each indexed value and its 
associated value is a set containing all the identifiers of the records whose property
match the indexed value.   

Unique indexes
--------------

Unique indexes are stored inside a single hash key named as 
`{s.db}:{s.name}_{property}`. Inside the hash, keys are the unique values 
associated to the indexed property and values are the record identifiers.
*/


module.exports = Records = (function(_super) {

  __extends(Records, _super);

  function Records(ron, schema) {
    this.redis = ron.redis;
    Records.__super__.constructor.call(this, ron, schema);
  }

  /*
  
    `all(callback)`
    ---------------
    Return all records. Similar to the find method with far less options 
    and a faster implementation.
  */


  Records.prototype.all = function(callback) {
    var db, identifier, name, redis, _ref,
      _this = this;
    redis = this.redis;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier;
    return redis.smembers("" + db + ":" + name + "_" + identifier, function(err, recordIds) {
      var multi, recordId, _i, _len;
      multi = redis.multi();
      for (_i = 0, _len = recordIds.length; _i < _len; _i++) {
        recordId = recordIds[_i];
        multi.hgetall("" + db + ":" + name + ":" + recordId);
      }
      return multi.exec(function(err, records) {
        if (err) {
          return callback(err);
        }
        _this.unserialize(records);
        return callback(null, records);
      });
    });
  };

  /*
  
    `clear(callback)`
    -----------------
    Remove all the records and the references poiting to them. This function
    takes no other argument than the callback called on error or success.   
  
    `callback`        Received parameters are:   
  
    *   `err`         Error object if any.   
    *   `count`       Number of removed records on success   
    
    Usage: 
  
        ron.get('users').clear (err, count) ->
          return console.error "Failed: #{err.message}" if err
          console.log "#{count} records removed"
  */


  Records.prototype.clear = function(callback) {
    var cmds, count, db, hash, identifier, index, indexProperties, indexSort, multi, name, property, redis, unique, _i, _len, _ref;
    redis = this.redis, hash = this.hash;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, index = _ref.index, unique = _ref.unique;
    cmds = [];
    count = 0;
    multi = redis.multi();
    indexSort = [];
    indexProperties = Object.keys(index);
    if (indexProperties.length) {
      indexSort.push("" + db + ":" + name + "_" + identifier);
      for (_i = 0, _len = indexProperties.length; _i < _len; _i++) {
        property = indexProperties[_i];
        indexSort.push('get');
        indexSort.push("" + db + ":" + name + ":*->" + property);
        cmds.push(['del', "" + db + ":" + name + "_" + property + ":null"]);
      }
      indexSort.push(function(err, values) {
        var i, j, value, _j, _ref1, _ref2, _results;
        if (values.length) {
          _results = [];
          for (i = _j = 0, _ref1 = values.length, _ref2 = indexProperties.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = _j += _ref2) {
            _results.push((function() {
              var _k, _len1, _results1;
              _results1 = [];
              for (j = _k = 0, _len1 = indexProperties.length; _k < _len1; j = ++_k) {
                property = indexProperties[j];
                value = hash(values[i + j]);
                _results1.push(cmds.push(['del', "" + db + ":" + name + "_" + property + ":" + value]));
              }
              return _results1;
            })());
          }
          return _results;
        }
      });
      multi.sort.apply(multi, indexSort);
    }
    multi.smembers("" + db + ":" + name + "_" + identifier, function(err, recordIds) {
      var recordId, _j, _len1, _results;
      if (err) {
        return callback(err);
      }
      if (recordIds == null) {
        recordIds = [];
      }
      count = recordIds.length;
      for (_j = 0, _len1 = recordIds.length; _j < _len1; _j++) {
        recordId = recordIds[_j];
        cmds.push(['del', "" + db + ":" + name + ":" + recordId]);
      }
      cmds.push(['del', "" + db + ":" + name + "_incr"]);
      cmds.push(['del', "" + db + ":" + name + "_" + identifier]);
      for (property in unique) {
        cmds.push(['del', "" + db + ":" + name + "_" + property]);
      }
      _results = [];
      for (property in index) {
        _results.push(cmds.push(['del', "" + db + ":" + name + "_" + property]));
      }
      return _results;
    });
    return multi.exec(function(err, results) {
      if (err) {
        return callback(err);
      }
      multi = redis.multi(cmds);
      return multi.exec(function(err, results) {
        if (err) {
          return callback(err);
        }
        return callback(null, count);
      });
    });
  };

  /*
  
    `count(callback)`
    -----------------
    Count the number of records present in the database.  
  
    Counting all the records:   
  
        Users.count, (err, count) ->
          console.log 'count users', count
  
    `count(property, values, callback)`
    ----------------------------------
    Count the number of one or more values for an indexed property.  
  
    Counting multiple values:   
  
        Users.get 'users', properties:
          user_id: identifier: true
          job: index: true
        Users.count 'job' [ 'globtrotter', 'icemaker' ], (err, counts) ->
          console.log 'count globtrotter', counts[0]
          console.log 'count icemaker', counts[1]
  */


  Records.prototype.count = function(callback) {
    var db, i, identifier, index, isArray, multi, name, property, redis, value, values, _i, _len, _ref;
    redis = this.redis;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, index = _ref.index;
    if (arguments.length === 3) {
      property = callback;
      values = arguments[1];
      callback = arguments[2];
      if (!index[property]) {
        return callback(new Error("Property is not indexed"));
      }
      isArray = Array.isArray(values);
      if (!isArray) {
        values = [values];
      }
      multi = redis.multi();
      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
        value = values[i];
        value = this.hash(value);
        multi.scard("" + db + ":" + name + "_" + property + ":" + value);
      }
      return multi.exec(function(err, counts) {
        if (err) {
          return callback(err);
        }
        return callback(null, isArray ? counts : counts[0]);
      });
    } else {
      return this.redis.scard("" + db + ":" + name + "_" + identifier, function(err, count) {
        if (err) {
          return callback(err);
        }
        return callback(null, count);
      });
    }
  };

  /*
  
    `create(records, [options], callback)`
    --------------------------------------
    Insert one or multiple record. The records must not already exists 
    in the database or an error will be returned in the callback. Only
    the defined properties are inserted.
  
    The records passed to the function are returned in the callback enriched their new identifier property.
  
    `records`             Record object or array of record objects.   
  
    `options`             Options properties include:   
  
    *   `identifiers`     Return only the created identifiers instead of the records.   
    *   `validate`        Validate the records.   
    *   `properties`      Array of properties to be returned.   
    *   `milliseconds`    Convert date value to milliseconds timestamps instead of `Date` objects.   
    *   `seconds`         Convert date value to seconds timestamps instead of `Date` objects.   
  
    `callback`            Called on success or failure. Received parameters are:   
  
    *   `err`             Error object if any.   
    *   `records`         Records with their newly created identifier.   
  
    Records are not validated, it is the responsability of the client program calling `create` to either
    call `validate` before calling `create` or to passs the `validate` options.
  */


  Records.prototype.create = function(records, options, callback) {
    var db, hash, identifier, index, isArray, name, properties, redis, temporal, unique, _ref,
      _this = this;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    redis = this.redis, hash = this.hash;
    _ref = this.data, db = _ref.db, name = _ref.name, temporal = _ref.temporal, properties = _ref.properties, identifier = _ref.identifier, index = _ref.index, unique = _ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.validate) {
      try {
        this.validate(records, {
          "throw": true
        });
      } catch (e) {
        return callback(e, (isArray ? records : records[0]));
      }
    }
    return this.exists(records, function(err, recordIds) {
      var date, multi, recordId, _i, _len;
      if (err) {
        return callback(err);
      }
      for (_i = 0, _len = recordIds.length; _i < _len; _i++) {
        recordId = recordIds[_i];
        if (recordId != null) {
          return callback(new Error("Record " + recordId + " already exists"));
        }
      }
      multi = redis.multi();
      if (temporal != null) {
        date = new Date(Date.now());
      }
      return _this.id(records, function(err, records) {
        var i, property, r, record, value, _j, _len1;
        multi = redis.multi();
        for (i = _j = 0, _len1 = records.length; _j < _len1; i = ++_j) {
          record = records[i];
          if (((temporal != null ? temporal.creation : void 0) != null) && !(record[temporal.creation] != null)) {
            record[temporal.creation] = date;
          }
          if (((temporal != null ? temporal.modification : void 0) != null) && !(record[temporal.modification] != null)) {
            record[temporal.modification] = date;
          }
          multi.sadd("" + db + ":" + name + "_" + identifier, record[identifier]);
          for (property in unique) {
            if (record[property]) {
              multi.hset("" + db + ":" + name + "_" + property, record[property], record[identifier]);
            }
          }
          for (property in index) {
            value = record[property];
            value = hash(value);
            multi.sadd("" + db + ":" + name + "_" + property + ":" + value, record[identifier]);
          }
          r = {};
          for (property in record) {
            value = record[property];
            if (!properties[property]) {
              continue;
            }
            if (value != null) {
              r[property] = value;
            }
          }
          _this.serialize(r);
          multi.hmset("" + db + ":" + name + ":" + record[identifier], r);
        }
        return multi.exec(function(err, results) {
          var result, _k, _len2;
          if (err) {
            return callback(err);
          }
          for (_k = 0, _len2 = results.length; _k < _len2; _k++) {
            result = results[_k];
            if (result[0] === !"0") {
              return callback(new Error('Corrupted user database '));
            }
          }
          _this.unserialize(records, options);
          return callback(null, isArray ? records : records[0]);
        });
      });
    });
  };

  /*
    
    `exists(records, callback)`
    ---------------------------
    Check if one or more record exist. The existence of a record is based on its 
    id or any property defined as unique. The provided callback is called with 
    an error or the records identifiers. The identifiers respect the same 
    structure as the provided records argument. If a record does not exists, 
    its associated return value is null.   
  
    `records`           Record object or array of record objects.   
  
    `callback`          Called on success or failure. Received parameters are:   
  
    *   `err`           Error object if any.   
    *   `identifier`    Record identifiers or null values.
  */


  Records.prototype.exists = function(records, callback) {
    var db, identifier, isArray, multi, name, property, record, recordId, redis, unique, _i, _len, _ref,
      _this = this;
    redis = this.redis;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, unique = _ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    multi = redis.multi();
    for (_i = 0, _len = records.length; _i < _len; _i++) {
      record = records[_i];
      if (typeof record === 'object') {
        if (record[identifier] != null) {
          recordId = record[identifier];
          multi.hget("" + db + ":" + name + ":" + recordId, identifier);
        } else {
          for (property in unique) {
            if (record[property] != null) {
              multi.hget("" + db + ":" + name + "_" + property, record[property]);
            }
          }
        }
      } else {
        multi.hget("" + db + ":" + name + ":" + record, identifier);
      }
    }
    return multi.exec(function(err, recordIds) {
      if (err) {
        return callback(err);
      }
      _this.unserialize(recordIds);
      return callback(null, isArray ? recordIds : recordIds[0]);
    });
  };

  /*
  
    `get(records, [options], callback)`
    -----------------------------------
    Retrieve one or multiple records. Records that doesn't exists are returned as null. If 
    options is an array, it is considered to be the list of properties to retrieve. By default, 
    unless the `force` option is defined, only the properties not yet defined in the provided 
    records are fetched from Redis.   
  
    `options`             All options are optional. Options properties include:   
    
    *   `properties`      Array of properties to fetch, all properties unless defined.   
    *   `force`           Force the retrieval of properties even if already present in the record objects.   
    *   `accept_null`     Skip objects if they are provided as null.   
    *   `object`          If `true`, return an object where keys are the identifier and value are the fetched records
  
    `callback`            Called on success or failure. Received parameters are:   
  
    *   `err`             Error object if the command failed.   
    *   `records`         Object or array of object if command succeed. Objects are null if records are not found.
  */


  Records.prototype.get = function(records, options, callback) {
    var db, identifier, isArray, name, redis, _ref,
      _this = this;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    if (Array.isArray(options)) {
      options = {
        properties: options
      };
    }
    redis = this.redis;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if ((options.accept_null != null) && !records.some(function(record) {
      return record !== null;
    })) {
      return callback(null, isArray ? records : records[0]);
    }
    return this.identify(records, {
      object: true,
      accept_null: options.accept_null != null
    }, function(err, records) {
      var cmds, multi;
      if (err) {
        return callback(err);
      }
      cmds = [];
      records.forEach(function(record, i) {
        var recordId, _ref1;
        if (record == null) {
          return;
        }
        recordId = record[identifier];
        if (recordId === null) {
          records[i] = null;
        } else if ((_ref1 = options.properties) != null ? _ref1.length : void 0) {
          options.properties.forEach(function(property) {
            if (!(options.force || record[property])) {
              return cmds.push([
                'hget', "" + db + ":" + name + ":" + recordId, property, function(err, value) {
                  return record[property] = value;
                }
              ]);
            }
          });
        } else {
          cmds.push([
            'hgetall', "" + db + ":" + name + ":" + recordId, function(err, values) {
              var property, value, _results;
              _results = [];
              for (property in values) {
                value = values[property];
                _results.push(record[property] = value);
              }
              return _results;
            }
          ]);
        }
        return cmds.push([
          'exists', "" + db + ":" + name + ":" + recordId, function(err, exists) {
            if (!exists) {
              return records[i] = null;
            }
          }
        ]);
      });
      if (cmds.length === 0) {
        return callback(null, isArray ? records : records[0]);
      }
      multi = redis.multi(cmds);
      return multi.exec(function(err, values) {
        var record, recordsByIds, _i, _len;
        if (err) {
          return callback(err);
        }
        _this.unserialize(records);
        if (options.object) {
          recordsByIds = {};
          for (_i = 0, _len = records.length; _i < _len; _i++) {
            record = records[_i];
            recordsByIds[record[identifier]] = record;
          }
          return callback(null, recordsByIds);
        } else {
          return callback(null, isArray ? records : records[0]);
        }
      });
    });
  };

  /*
    `id(records, callback)`
    -----------------------
    Generate new identifiers. The first arguments `records` may be the number
    of ids to generate, a record or an array of records.
  */


  Records.prototype.id = function(records, callback) {
    var db, i, identifier, incr, isArray, name, record, redis, unique, _i, _len, _ref,
      _this = this;
    redis = this.redis;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, unique = _ref.unique;
    if (typeof records === 'number') {
      incr = records;
      isArray = true;
      records = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= records ? _i < records : _i > records; i = 0 <= records ? ++_i : --_i) {
          _results.push(null);
        }
        return _results;
      })();
    } else {
      isArray = Array.isArray(records);
      if (!isArray) {
        records = [records];
      }
      incr = 0;
      for (_i = 0, _len = records.length; _i < _len; _i++) {
        record = records[_i];
        if (!record[identifier]) {
          incr++;
        }
      }
    }
    return redis.incrby("" + db + ":" + name + "_incr", incr, function(err, recordId) {
      var _j, _len1;
      recordId = recordId - incr;
      if (err) {
        return callback(err);
      }
      for (i = _j = 0, _len1 = records.length; _j < _len1; i = ++_j) {
        record = records[i];
        if (!record) {
          records[i] = record = {};
        }
        if (!record[identifier]) {
          recordId++;
        }
        if (!record[identifier]) {
          record[identifier] = recordId;
        }
      }
      return callback(null, isArray ? records : records[0]);
    });
  };

  /*
  
    `identify(records, [options], callback)`
    ----------------------------------------
    Extract record identifiers or set the identifier to null if its associated record could not be found.   
  
    The method doesn't hit the database to validate record values and if an id is 
    provided, it wont check its existence. When a record has no identifier but a unique value, then its
    identifier will be fetched from Redis.   
  
    `records`             Record object or array of record objects.   
  
    `options`             Options properties include:   
  
    *   `accept_null`     Skip objects if they are provided as null.   
    *   `object`          Return an object in the callback even if it recieve an id instead of a record.   
  
    Use reverse index lookup to extract user ids:   
  
        Users.get 'users', properties:
          user_id: identifier: true
          username: unique: true
        Users.id [
          {username: 'username_1'}
          {username: 'username_2'}
        ], (err, ids) ->
          should.not.exist err
          console.log ids
  
    Use the `object` option to return records instead of ids:   
  
        Users.get 'users', properties:
          user_id: identifier: true
          username: unique: true
        Users.id [
          1, {user_id: 2} ,{username: 'username_3'}
        ], object: true, (err, users) ->
          should.not.exist err
          ids = for user in users then user.user_id
          console.log ids
  */


  Records.prototype.identify = function(records, options, callback) {
    var cmds, db, err, finalize, i, identifier, isArray, multi, name, property, record, redis, unique, withUnique, _i, _len, _ref,
      _this = this;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    redis = this.redis;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, unique = _ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    cmds = [];
    err = null;
    for (i = _i = 0, _len = records.length; _i < _len; i = ++_i) {
      record = records[i];
      if (typeof record === 'object') {
        if (record == null) {
          if (!options.accept_null) {
            return callback(new Error('Null record'));
          }
        } else if (record[identifier] != null) {

        } else {
          withUnique = false;
          for (property in unique) {
            if (record[property] != null) {
              withUnique = true;
              cmds.push([
                'hget', "" + db + ":" + name + "_" + property, record[property], (function(record) {
                  return function(err, recordId) {
                    return record[identifier] = recordId;
                  };
                })(record)
              ]);
            }
          }
          if (!withUnique) {
            return callback(new Error('Invalid record, got ' + (JSON.stringify(record))));
          }
        }
      } else if (typeof record === 'number' || typeof record === 'string') {
        records[i] = {};
        records[i][identifier] = record;
      } else {
        return callback(new Error('Invalid id, got ' + (JSON.stringify(record))));
      }
    }
    finalize = function() {
      if (!options.object) {
        records = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            record = records[_j];
            if (record != null) {
              _results.push(record[identifier]);
            } else {
              _results.push(record);
            }
          }
          return _results;
        })();
      }
      return callback(null, isArray ? records : records[0]);
    };
    if (cmds.length === 0) {
      return finalize();
    }
    multi = redis.multi(cmds);
    return multi.exec(function(err, results) {
      if (err) {
        return callback(err);
      }
      _this.unserialize(records);
      return finalize();
    });
  };

  /*
  
    `list([options], callback)`
    ---------------------------
    List records with support for filtering and sorting.   
  
    `options`             Options properties include:   
  
    *   `direction`       One of `asc` or `desc`, default to `asc`.   
    *   `identifiers`     Return an array of identifiers instead of the record objects.  
    *   `milliseconds`    Convert date value to milliseconds timestamps instead of `Date` objects.   
    *   `properties`      Array of properties to be returned.   
    *   `operation`       Redis operation in case of multiple `where` properties, default to `union`.   
    *   `seconds`         Convert date value to seconds timestamps instead of `Date` objects.   
    *   `sort`            Name of the property by which records should be ordered.   
    *   `where`           Hash of property/value used to filter the query.   
  
    `callback`            Called on success or failure. Received parameters are:   
  
    *   `err`             Error object if any.   
    *   `records`         Records fetched from Redis.   
  
    Using the `union` operation:   
  
        Users.list
          where: group: ['admin', 'redis']
          operation: 'union'
          direction: 'desc'
        , (err, users) ->
          console.log users
    
    An alternative syntax is to bypass the `where` option, the exemple above
    could be rewritten as:   
  
        Users.list
          group: ['admin', 'redis']
          operation: 'union'
          direction: 'desc'
        , (err, users) ->
          console.log users
  */


  Records.prototype.list = function(options, callback) {
    var args, db, filter, hash, identifier, index, keys, multi, name, operation, property, redis, tempkey, v, value, where, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4,
      _this = this;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    redis = this.redis, hash = this.hash;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, index = _ref.index;
    options.properties = options.properties || Object.keys(this.data.properties);
    if (options.identifiers) {
      options.properties = [identifier];
    }
    args = [];
    multi = this.redis.multi();
    if (options.where == null) {
      options.where = {};
    }
    where = [];
    for (property in options) {
      value = options[property];
      if (index[property]) {
        if (Array.isArray(value)) {
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            v = value[_i];
            where.push([property, v]);
          }
        } else {
          where.push([property, value]);
        }
      }
    }
    options.where = Object.keys(options.where).length ? options.where : false;
    if (where.length === 1) {
      _ref1 = where[0], property = _ref1[0], value = _ref1[1];
      value = hash(value);
      args.push("" + db + ":" + name + "_" + property + ":" + value);
    } else if (where.length > 1) {
      tempkey = "temp:" + ((new Date).getTime()) + (Math.random());
      keys = [];
      keys.push(tempkey);
      args.push(tempkey);
      for (_j = 0, _len1 = where.length; _j < _len1; _j++) {
        filter = where[_j];
        property = filter[0], value = filter[1];
        value = hash(value);
        keys.push("" + db + ":" + name + "_" + property + ":" + value);
      }
      operation = (_ref2 = options.operation) != null ? _ref2 : 'union';
      multi["s" + operation + "store"].apply(multi, keys);
    } else {
      args.push("" + db + ":" + name + "_" + identifier);
    }
    if (options.sort != null) {
      args.push('by');
      args.push(("" + db + ":" + name + ":*->") + options.sort);
    }
    _ref3 = options.properties;
    for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
      property = _ref3[_k];
      args.push('get');
      args.push(("" + db + ":" + name + ":*->") + property);
    }
    args.push('alpha');
    args.push((_ref4 = options.direction) != null ? _ref4 : 'asc');
    args.push(function(err, values) {
      var i, j, record, result;
      if (err) {
        return callback(err);
      }
      if (!values.length) {
        return callback(null, []);
      }
      result = (function() {
        var _l, _len3, _m, _ref5, _ref6, _ref7, _results;
        _results = [];
        for (i = _l = 0, _ref5 = values.length, _ref6 = options.properties.length; 0 <= _ref5 ? _l < _ref5 : _l > _ref5; i = _l += _ref6) {
          record = {};
          _ref7 = options.properties;
          for (j = _m = 0, _len3 = _ref7.length; _m < _len3; j = ++_m) {
            property = _ref7[j];
            record[property] = values[i + j];
          }
          _results.push(this.unserialize(record, options));
        }
        return _results;
      }).call(_this);
      return callback(null, result);
    });
    multi.sort.apply(multi, args);
    if (tempkey) {
      multi.del(tempkey);
    }
    return multi.exec();
  };

  /*
    
    `remove(records, callback)`
    ---------------------------
    Remove one or several records from the database. The function will also 
    handle all the indexes referencing those records.   
  
    `records`           Record object or array of record objects.   
  
    `callback`          Called on success or failure. Received parameters are:   
  
    *   `err`           Error object if any.   
    *   `removed`       Number of removed records.  
  
    Removing a single record:   
  
        Users.remove id, (err, removed) ->
          console.log "#{removed} user removed"
  */


  Records.prototype.remove = function(records, callback) {
    var db, hash, identifier, index, isArray, name, redis, removed, unique, _ref;
    redis = this.redis, hash = this.hash;
    _ref = this.data, db = _ref.db, name = _ref.name, identifier = _ref.identifier, index = _ref.index, unique = _ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    removed = 0;
    return this.get(records, [].concat(Object.keys(unique), Object.keys(index)), function(err, records) {
      var multi, record, _fn, _i, _len;
      if (err) {
        return callback(err);
      }
      multi = redis.multi();
      _fn = function(record) {
        var property, recordId, value, _results;
        recordId = record[identifier];
        multi.del("" + db + ":" + name + ":" + recordId, function(err) {
          return removed++;
        });
        multi.srem("" + db + ":" + name + "_" + identifier, recordId);
        for (property in unique) {
          multi.hdel("" + db + ":" + name + "_" + property, record[property]);
        }
        _results = [];
        for (property in index) {
          value = hash(record[property]);
          _results.push(multi.srem("" + db + ":" + name + "_" + property + ":" + value, recordId, function(err, count) {
            if (count !== 1) {
              return console.warn('Missing indexed property');
            }
          }));
        }
        return _results;
      };
      for (_i = 0, _len = records.length; _i < _len; _i++) {
        record = records[_i];
        if (record === null) {
          continue;
        }
        _fn(record);
      }
      return multi.exec(function(err, results) {
        if (err) {
          return callback(err);
        }
        return callback(null, removed);
      });
    });
  };

  /*
    
    `update(records, [options], callback)` 
    --------------------------------------
    Update one or several records. The records must exists in the database or 
    an error will be returned in the callback. The existence of a record may 
    be discovered through its identifier or the presence of a unique property.   
    
    `records`           Record object or array of record objects.   
    
    `options`           Options properties include:   
    
    *   `validate`      Validate the records.   
    
    `callback`          Called on success or failure. Received parameters are:   
    
    *   `err`           Error object if any.   
    *   `records`       Records with their newly created identifier.   
    
    Records are not validated, it is the responsability of the client program to either
    call `validate` before calling `update` or to passs the `validate` options.   
    
    Updating a single record:   
  
        Users.update
          username: 'my_username'
          age: 28
        , (err, user) -> console.log user
  */


  Records.prototype.update = function(records, options, callback) {
    var db, hash, identifier, index, isArray, name, properties, redis, temporal, unique, _ref,
      _this = this;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    redis = this.redis, hash = this.hash;
    _ref = this.data, db = _ref.db, name = _ref.name, temporal = _ref.temporal, properties = _ref.properties, identifier = _ref.identifier, unique = _ref.unique, index = _ref.index;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.validate) {
      try {
        this.validate(records, {
          "throw": true,
          skip_required: true
        });
      } catch (e) {
        return callback(e, (isArray ? records : records[0]));
      }
    }
    return this.identify(records, {
      object: true
    }, function(err, records) {
      var cmdsCheck, cmdsUpdate, multi, property, r, record, recordId, value, _fn, _i, _j, _len, _len1;
      if (err) {
        return callback(err);
      }
      for (_i = 0, _len = records.length; _i < _len; _i++) {
        record = records[_i];
        if (!record) {
          return callback(new Error('Invalid record'));
        }
      }
      cmdsCheck = [];
      cmdsUpdate = [];
      multi = redis.multi();
      _fn = function(record) {
        var potentiallyChangedProperties, property, recordId, _k, _len2, _ref1;
        recordId = record[identifier];
        potentiallyChangedProperties = [];
        _ref1 = [].concat(Object.keys(unique), Object.keys(index));
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          property = _ref1[_k];
          if (typeof record[property] !== 'undefined') {
            potentiallyChangedProperties.push(property);
          }
        }
        if (potentiallyChangedProperties.length) {
          return multi.hmget.apply(multi, ["" + db + ":" + name + ":" + recordId].concat(__slice.call(potentiallyChangedProperties), [function(err, values) {
            var propertyI, valueNew, valueOld, _l, _len3, _results;
            _results = [];
            for (propertyI = _l = 0, _len3 = potentiallyChangedProperties.length; _l < _len3; propertyI = ++_l) {
              property = potentiallyChangedProperties[propertyI];
              if (values[propertyI] !== record[property]) {
                if (properties[property].unique) {
                  cmdsCheck.push(['hexists', "" + db + ":" + name + "_" + property, record[property]]);
                  cmdsUpdate.push(['hdel', "" + db + ":" + name + "_" + property, values[propertyI]]);
                  _results.push(cmdsUpdate.push([
                    'hsetnx', "" + db + ":" + name + "_" + property, record[property], recordId, function(err, success) {
                      if (!success) {
                        return console.warn('Trying to write on existing unique property');
                      }
                    }
                  ]));
                } else if (properties[property].index) {
                  valueOld = hash(values[propertyI]);
                  valueNew = hash(record[property]);
                  cmdsUpdate.push(['srem', "" + db + ":" + name + "_" + property + ":" + valueOld, recordId]);
                  _results.push(cmdsUpdate.push(['sadd', "" + db + ":" + name + "_" + property + ":" + valueNew, recordId]));
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }]));
        }
      };
      for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
        record = records[_j];
        recordId = record[identifier];
        if (!recordId) {
          return callback(new Error('Unsaved record'));
        }
        if (((temporal != null ? temporal.modification : void 0) != null) && !(record[temporal.modification] != null)) {
          record[temporal.modification] = new Date(Date.now());
        }
        r = {};
        for (property in record) {
          value = record[property];
          if (value != null) {
            r[property] = value;
          } else {
            cmdsUpdate.push(['hdel', "" + db + ":" + name + ":" + recordId, property]);
          }
        }
        _this.serialize(r);
        cmdsUpdate.push(['hmset', "" + db + ":" + name + ":" + recordId, r]);
        _fn(record);
      }
      return multi.exec(function(err, values) {
        multi = redis.multi(cmdsCheck);
        return multi.exec(function(err, exists) {
          var exist, _k, _len2;
          if (err) {
            return callback(err);
          }
          for (_k = 0, _len2 = exists.length; _k < _len2; _k++) {
            exist = exists[_k];
            if (exist !== 0) {
              return callback(new Error('Unique value already exists'));
            }
          }
          multi = redis.multi(cmdsUpdate);
          return multi.exec(function(err, results) {
            if (err) {
              return callback(err);
            }
            return callback(null, isArray ? records : records[0]);
          });
        });
      });
    });
  };

  return Records;

})(Schema);
