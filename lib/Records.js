// Generated by CoffeeScript 1.12.3
var Records, Schema,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

Schema = require('./Schema');


/*

Records access and manipulation
===============================

Implement object based storage with indexing support.   

Identifier
----------

Auto generated identifiers are incremented integers. The next identifier is obtained from
a key named as `{s.db}:{s.name}_incr`. All the identifiers are stored as a Redis set in 
a key named as `{s.db}:{s.name}_#{identifier}`.   

Data
----

Records data is stored as a single hash named as `{s.db}:{s.name}:{idenfitier}`. The hash
keys map to the record properties and the hash value map to the values associated with
each properties.   

Regular indexes
---------------

Regular index are stored inside multiple sets, named as
`{s.db}:{s.name}_{property}:{value}`. There is one key for each indexed value and its 
associated value is a set containing all the identifiers of the records whose property
match the indexed value.   

Unique indexes
--------------

Unique indexes are stored inside a single hash key named as 
`{s.db}:{s.name}_{property}`. Inside the hash, keys are the unique values 
associated to the indexed property and values are the record identifiers.
 */

module.exports = Records = (function(superClass) {
  extend(Records, superClass);

  function Records(ron, schema) {
    this.redis = ron.redis;
    Records.__super__.constructor.call(this, ron, schema);
  }


  /*
  
  `all(callback)`
  ---------------
  Return all records. Similar to the find method with far less options 
  and a faster implementation.
   */

  Records.prototype.all = function(callback) {
    var db, identifier, name, redis, ref;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier;
    return redis.smembers(db + ":" + name + "_" + identifier, (function(_this) {
      return function(err, recordIds) {
        var k, len, multi, recordId;
        multi = redis.multi();
        for (k = 0, len = recordIds.length; k < len; k++) {
          recordId = recordIds[k];
          multi.hgetall(db + ":" + name + ":" + recordId);
        }
        return multi.exec(function(err, records) {
          if (err) {
            return callback(err);
          }
          _this.unserialize(records);
          return callback(null, records);
        });
      };
    })(this));
  };


  /*
  
  `clear(callback)`
  -----------------
  Remove all the records and the references poiting to them. This function
  takes no other argument than the callback called on error or success.   
  
  `callback`        Received parameters are:   
  
  *   `err`         Error object if any.   
  *   `count`       Number of removed records on success   
  
  Usage: 
  
      ron.get('users').clear (err, count) ->
        return console.error "Failed: #{err.message}" if err
        console.log "#{count} records removed"
   */

  Records.prototype.clear = function(callback) {
    var cmds, count, db, hash, identifier, index, indexProperties, indexSort, k, len, multi, name, property, redis, ref, ref1, unique;
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, identifier = ref1.identifier, index = ref1.index, unique = ref1.unique;
    cmds = [];
    count = 0;
    multi = redis.multi();
    indexSort = [];
    indexProperties = Object.keys(index);
    if (indexProperties.length) {
      indexSort.push(db + ":" + name + "_" + identifier);
      for (k = 0, len = indexProperties.length; k < len; k++) {
        property = indexProperties[k];
        indexSort.push('get');
        indexSort.push(db + ":" + name + ":*->" + property);
        cmds.push(['del', db + ":" + name + "_" + property + ":null"]);
      }
      indexSort.push(function(err, values) {
        var i, j, l, ref2, ref3, results1, value;
        if (values.length) {
          results1 = [];
          for (i = l = 0, ref2 = values.length, ref3 = indexProperties.length; ref3 > 0 ? l < ref2 : l > ref2; i = l += ref3) {
            results1.push((function() {
              var len1, m, results2;
              results2 = [];
              for (j = m = 0, len1 = indexProperties.length; m < len1; j = ++m) {
                property = indexProperties[j];
                value = hash(values[i + j]);
                results2.push(cmds.push(['del', db + ":" + name + "_" + property + ":" + value]));
              }
              return results2;
            })());
          }
          return results1;
        }
      });
      multi.sort.apply(multi, indexSort);
    }
    multi.smembers(db + ":" + name + "_" + identifier, function(err, recordIds) {
      var l, len1, recordId, results1;
      if (err) {
        return callback(err);
      }
      if (recordIds == null) {
        recordIds = [];
      }
      count = recordIds.length;
      for (l = 0, len1 = recordIds.length; l < len1; l++) {
        recordId = recordIds[l];
        cmds.push(['del', db + ":" + name + ":" + recordId]);
      }
      cmds.push(['del', db + ":" + name + "_incr"]);
      cmds.push(['del', db + ":" + name + "_" + identifier]);
      for (property in unique) {
        cmds.push(['del', db + ":" + name + "_" + property]);
      }
      results1 = [];
      for (property in index) {
        results1.push(cmds.push(['del', db + ":" + name + "_" + property]));
      }
      return results1;
    });
    return multi.exec(function(err, results) {
      if (err) {
        return callback(err);
      }
      multi = redis.multi(cmds);
      return multi.exec(function(err, results) {
        if (err) {
          return callback(err);
        }
        return callback(null, count);
      });
    });
  };


  /*
  
  `count(callback)`
  -----------------
  Count the number of records present in the database.  
  
  Counting all the records:   
  
      Users.count, (err, count) ->
        console.log 'count users', count
  
  `count(property, values, callback)`
  ----------------------------------
  Count the number of one or more values for an indexed property.  
  
  Counting multiple values:   
  
      Users.get 'users', properties:
        user_id: identifier: true
        job: index: true
      Users.count 'job' [ 'globtrotter', 'icemaker' ], (err, counts) ->
        console.log 'count globtrotter', counts[0]
        console.log 'count icemaker', counts[1]
   */

  Records.prototype.count = function(callback) {
    var db, i, identifier, index, isArray, k, len, multi, name, property, redis, ref, value, values;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, index = ref.index;
    if (arguments.length === 3) {
      property = callback;
      values = arguments[1];
      callback = arguments[2];
      if (!index[property]) {
        return callback(new Error("Property is not indexed"));
      }
      isArray = Array.isArray(values);
      if (!isArray) {
        values = [values];
      }
      multi = redis.multi();
      for (i = k = 0, len = values.length; k < len; i = ++k) {
        value = values[i];
        value = this.hash(value);
        multi.scard(db + ":" + name + "_" + property + ":" + value);
      }
      return multi.exec(function(err, counts) {
        if (err) {
          return callback(err);
        }
        return callback(null, isArray ? counts : counts[0]);
      });
    } else {
      return this.redis.scard(db + ":" + name + "_" + identifier, function(err, count) {
        if (err) {
          return callback(err);
        }
        return callback(null, count);
      });
    }
  };


  /*
  
  `create(records, [options], callback)`
  --------------------------------------
  Insert one or multiple record. The records must not already exists 
  in the database or an error will be returned in the callback. Only
  the defined properties are inserted.
  
  The records passed to the function are returned in the callback enriched their new identifier property.
  
  `records`             Record object or array of record objects.   
  
  `options`             Options properties include:   
  
  *   `identifiers`     Return only the created identifiers instead of the records.   
  *   `validate`        Validate the records.   
  *   `properties`      Array of properties to be returned.   
  *   `milliseconds`    Convert date value to milliseconds timestamps instead of `Date` objects.   
  *   `seconds`         Convert date value to seconds timestamps instead of `Date` objects.   
  
  `callback`            Called on success or failure. Received parameters are:   
  
  *   `err`             Error object if any.   
  *   `records`         Records with their newly created identifier.   
  
  Records are not validated, it is the responsability of the client program calling `create` to either
  call `validate` before calling `create` or to passs the `validate` options.
   */

  Records.prototype.create = function(records, options, callback) {
    var db, e, hash, identifier, index, isArray, name, properties, redis, ref, ref1, temporal, unique;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, temporal = ref1.temporal, properties = ref1.properties, identifier = ref1.identifier, index = ref1.index, unique = ref1.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.validate) {
      try {
        this.validate(records, {
          "throw": true
        });
      } catch (error) {
        e = error;
        return callback(e, (isArray ? records : records[0]));
      }
    }
    return this.exists(records, (function(_this) {
      return function(err, recordIds) {
        var date, k, len, multi, recordId;
        if (err) {
          return callback(err);
        }
        for (k = 0, len = recordIds.length; k < len; k++) {
          recordId = recordIds[k];
          if (recordId != null) {
            return callback(new Error("Record " + recordId + " already exists"));
          }
        }
        multi = redis.multi();
        if (temporal != null) {
          date = new Date(Date.now());
        }
        return _this.id(records, function(err, records) {
          var i, l, len1, property, r, record, value;
          multi = redis.multi();
          for (i = l = 0, len1 = records.length; l < len1; i = ++l) {
            record = records[i];
            if (((temporal != null ? temporal.creation : void 0) != null) && (record[temporal.creation] == null)) {
              record[temporal.creation] = date;
            }
            if (((temporal != null ? temporal.modification : void 0) != null) && (record[temporal.modification] == null)) {
              record[temporal.modification] = date;
            }
            multi.sadd(db + ":" + name + "_" + identifier, record[identifier]);
            for (property in unique) {
              if (record[property]) {
                multi.hset(db + ":" + name + "_" + property, record[property], record[identifier]);
              }
            }
            for (property in index) {
              value = record[property];
              value = hash(value);
              multi.sadd(db + ":" + name + "_" + property + ":" + value, record[identifier]);
            }
            r = {};
            for (property in record) {
              value = record[property];
              if (!properties[property]) {
                continue;
              }
              if (value != null) {
                r[property] = value;
              }
            }
            _this.serialize(r);
            multi.hmset(db + ":" + name + ":" + record[identifier], r);
          }
          return multi.exec(function(err, results) {
            var len2, m, result;
            if (err) {
              return callback(err);
            }
            for (m = 0, len2 = results.length; m < len2; m++) {
              result = results[m];
              if (result[0] === !"0") {
                return callback(new Error('Corrupted user database '));
              }
            }
            _this.unserialize(records, options);
            return callback(null, isArray ? records : records[0]);
          });
        });
      };
    })(this));
  };


  /*
  
  `exists(records, callback)`
  ---------------------------
  Check if one or more record exist. The existence of a record is based on its 
  id or any property defined as unique. The provided callback is called with 
  an error or the records identifiers. The identifiers respect the same 
  structure as the provided records argument. If a record does not exists, 
  its associated return value is null.   
  
  `records`           Record object or array of record objects.   
  
  `callback`          Called on success or failure. Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `identifier`    Record identifiers or null values.
   */

  Records.prototype.exists = function(records, callback) {
    var db, identifier, isArray, k, len, multi, name, property, record, recordId, redis, ref, unique;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, unique = ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    multi = redis.multi();
    for (k = 0, len = records.length; k < len; k++) {
      record = records[k];
      if (typeof record === 'object') {
        if (record[identifier] != null) {
          recordId = record[identifier];
          multi.hget(db + ":" + name + ":" + recordId, identifier);
        } else {
          for (property in unique) {
            if (record[property] != null) {
              multi.hget(db + ":" + name + "_" + property, record[property]);
            }
          }
        }
      } else {
        multi.hget(db + ":" + name + ":" + record, identifier);
      }
    }
    return multi.exec((function(_this) {
      return function(err, recordIds) {
        if (err) {
          return callback(err);
        }
        _this.unserialize(recordIds);
        return callback(null, isArray ? recordIds : recordIds[0]);
      };
    })(this));
  };


  /*
  
  `get(records, [options], callback)`
  -----------------------------------
  Retrieve one or multiple records. Records that doesn't exists are returned as null. If 
  options is an array, it is considered to be the list of properties to retrieve. By default, 
  unless the `force` option is defined, only the properties not yet defined in the provided 
  records are fetched from Redis.   
  
  `options`             All options are optional. Options properties include:   
  
  *   `properties`      Array of properties to fetch, all properties unless defined.   
  *   `force`           Force the retrieval of properties even if already present in the record objects.   
  *   `accept_null`     Skip objects if they are provided as null.   
  *   `object`          If `true`, return an object where keys are the identifier and value are the fetched records
  
  `callback`            Called on success or failure. Received parameters are:   
  
  *   `err`             Error object if the command failed.   
  *   `records`         Object or array of object if command succeed. Objects are null if records are not found.
   */

  Records.prototype.get = function(records, options, callback) {
    var db, identifier, isArray, name, redis, ref;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    if (Array.isArray(options)) {
      options = {
        properties: options
      };
    }
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if ((options.accept_null != null) && !records.some(function(record) {
      return record !== null;
    })) {
      return callback(null, isArray ? records : records[0]);
    }
    return this.identify(records, {
      object: true,
      accept_null: options.accept_null != null
    }, (function(_this) {
      return function(err, records) {
        var cmds, multi;
        if (err) {
          return callback(err);
        }
        cmds = [];
        records.forEach(function(record, i) {
          var recordId, ref1;
          if (record == null) {
            return;
          }
          recordId = record[identifier];
          if (recordId === null) {
            records[i] = null;
          } else if ((ref1 = options.properties) != null ? ref1.length : void 0) {
            options.properties.forEach(function(property) {
              if (!(options.force || record[property])) {
                return cmds.push([
                  'hget', db + ":" + name + ":" + recordId, property, function(err, value) {
                    return record[property] = value;
                  }
                ]);
              }
            });
          } else {
            cmds.push([
              'hgetall', db + ":" + name + ":" + recordId, function(err, values) {
                var property, results1, value;
                results1 = [];
                for (property in values) {
                  value = values[property];
                  results1.push(record[property] = value);
                }
                return results1;
              }
            ]);
          }
          return cmds.push([
            'exists', db + ":" + name + ":" + recordId, function(err, exists) {
              if (!exists) {
                return records[i] = null;
              }
            }
          ]);
        });
        if (cmds.length === 0) {
          return callback(null, isArray ? records : records[0]);
        }
        multi = redis.multi(cmds);
        return multi.exec(function(err, values) {
          var k, len, record, recordsByIds;
          if (err) {
            return callback(err);
          }
          _this.unserialize(records);
          if (options.object) {
            recordsByIds = {};
            for (k = 0, len = records.length; k < len; k++) {
              record = records[k];
              recordsByIds[record[identifier]] = record;
            }
            return callback(null, recordsByIds);
          } else {
            return callback(null, isArray ? records : records[0]);
          }
        });
      };
    })(this));
  };


  /*
  `id(records, callback)`
  -----------------------
  Generate new identifiers. The first arguments `records` may be the number
  of ids to generate, a record or an array of records.
   */

  Records.prototype.id = function(records, callback) {
    var db, i, identifier, incr, isArray, k, len, name, record, redis, ref, unique;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, unique = ref.unique;
    if (typeof records === 'number') {
      incr = records;
      isArray = true;
      records = (function() {
        var k, ref1, results1;
        results1 = [];
        for (i = k = 0, ref1 = records; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          results1.push(null);
        }
        return results1;
      })();
    } else {
      isArray = Array.isArray(records);
      if (!isArray) {
        records = [records];
      }
      incr = 0;
      for (k = 0, len = records.length; k < len; k++) {
        record = records[k];
        if (!record[identifier]) {
          incr++;
        }
      }
    }
    return redis.incrby(db + ":" + name + "_incr", incr, (function(_this) {
      return function(err, recordId) {
        var l, len1;
        recordId = recordId - incr;
        if (err) {
          return callback(err);
        }
        for (i = l = 0, len1 = records.length; l < len1; i = ++l) {
          record = records[i];
          if (!record) {
            records[i] = record = {};
          }
          if (!record[identifier]) {
            recordId++;
          }
          if (!record[identifier]) {
            record[identifier] = recordId;
          }
        }
        return callback(null, isArray ? records : records[0]);
      };
    })(this));
  };


  /*
  
  `identify(records, [options], callback)`
  ----------------------------------------
  Extract record identifiers or set the identifier to null if its associated record could not be found.   
  
  The method doesn't hit the database to validate record values and if an id is 
  provided, it wont check its existence. When a record has no identifier but a unique value, then its
  identifier will be fetched from Redis.   
  
  `records`             Record object or array of record objects.   
  
  `options`             Options properties include:   
  
  *   `accept_null`     Skip objects if they are provided as null.   
  *   `object`          Return an object in the callback even if it recieve an id instead of a record.   
  
  Use reverse index lookup to extract user ids:   
  
      Users.get 'users', properties:
        user_id: identifier: true
        username: unique: true
      Users.id [
        {username: 'username_1'}
        {username: 'username_2'}
      ], (err, ids) ->
        should.not.exist err
        console.log ids
  
  Use the `object` option to return records instead of ids:   
  
      Users.get 'users', properties:
        user_id: identifier: true
        username: unique: true
      Users.id [
        1, {user_id: 2} ,{username: 'username_3'}
      ], object: true, (err, users) ->
        should.not.exist err
        ids = for user in users then user.user_id
        console.log ids
   */

  Records.prototype.identify = function(records, options, callback) {
    var cmds, db, err, finalize, i, identifier, isArray, k, len, multi, name, property, record, redis, ref, unique, withUnique;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, unique = ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    cmds = [];
    err = null;
    for (i = k = 0, len = records.length; k < len; i = ++k) {
      record = records[i];
      if (typeof record === 'object') {
        if (record == null) {
          if (!options.accept_null) {
            return callback(new Error('Null record'));
          }
        } else if (record[identifier] != null) {

        } else {
          withUnique = false;
          for (property in unique) {
            if (record[property] != null) {
              withUnique = true;
              cmds.push([
                'hget', db + ":" + name + "_" + property, record[property], (function(record) {
                  return function(err, recordId) {
                    return record[identifier] = recordId;
                  };
                })(record)
              ]);
            }
          }
          if (!withUnique) {
            return callback(new Error('Invalid record, got ' + (JSON.stringify(record))));
          }
        }
      } else if (typeof record === 'number' || typeof record === 'string') {
        records[i] = {};
        records[i][identifier] = record;
      } else {
        return callback(new Error('Invalid id, got ' + (JSON.stringify(record))));
      }
    }
    finalize = function() {
      if (!options.object) {
        records = (function() {
          var l, len1, results1;
          results1 = [];
          for (l = 0, len1 = records.length; l < len1; l++) {
            record = records[l];
            if (record != null) {
              results1.push(record[identifier]);
            } else {
              results1.push(record);
            }
          }
          return results1;
        })();
      }
      return callback(null, isArray ? records : records[0]);
    };
    if (cmds.length === 0) {
      return finalize();
    }
    multi = redis.multi(cmds);
    return multi.exec((function(_this) {
      return function(err, results) {
        if (err) {
          return callback(err);
        }
        _this.unserialize(records);
        return finalize();
      };
    })(this));
  };


  /*
  
  `list([options], callback)`
  ---------------------------
  List records with support for filtering and sorting.   
  
  `options`             Options properties include:   
  
  *   `direction`       One of `asc` or `desc`, default to `asc`.   
  *   `identifiers`     Return an array of identifiers instead of the record objects.  
  *   `milliseconds`    Convert date value to milliseconds timestamps instead of `Date` objects.   
  *   `properties`      Array of properties to be returned.   
  *   `operation`       Redis operation in case of multiple `where` properties, default to `union`.   
  *   `seconds`         Convert date value to seconds timestamps instead of `Date` objects.   
  *   `sort`            Name of the property by which records should be ordered.   
  *   `where`           Hash of property/value used to filter the query.   
  
  `callback`            Called on success or failure. Received parameters are:   
  
  *   `err`             Error object if any.   
  *   `records`         Records fetched from Redis.   
  
  Using the `union` operation:   
  
      Users.list
        where: group: ['admin', 'redis']
        operation: 'union'
        direction: 'desc'
      , (err, users) ->
        console.log users
  
  An alternative syntax is to bypass the `where` option, the exemple above
  could be rewritten as:   
  
      Users.list
        group: ['admin', 'redis']
        operation: 'union'
        direction: 'desc'
      , (err, users) ->
        console.log users
   */

  Records.prototype.list = function(options, callback) {
    var args, db, filter, hash, identifier, index, k, keys, l, len, len1, len2, m, multi, name, operation, property, redis, ref, ref1, ref2, ref3, ref4, ref5, tempkey, v, value, where;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, identifier = ref1.identifier, index = ref1.index;
    options.properties = options.properties || Object.keys(this.data.properties);
    if (options.identifiers) {
      options.properties = [identifier];
    }
    args = [];
    multi = this.redis.multi();
    if (options.where == null) {
      options.where = {};
    }
    where = [];
    for (property in options) {
      value = options[property];
      if (index[property]) {
        if (Array.isArray(value)) {
          for (k = 0, len = value.length; k < len; k++) {
            v = value[k];
            where.push([property, v]);
          }
        } else {
          where.push([property, value]);
        }
      }
    }
    options.where = Object.keys(options.where).length ? options.where : false;
    if (where.length === 1) {
      ref2 = where[0], property = ref2[0], value = ref2[1];
      value = hash(value);
      args.push(db + ":" + name + "_" + property + ":" + value);
    } else if (where.length > 1) {
      tempkey = "temp:" + ((new Date).getTime()) + (Math.random());
      keys = [];
      keys.push(tempkey);
      args.push(tempkey);
      for (l = 0, len1 = where.length; l < len1; l++) {
        filter = where[l];
        property = filter[0], value = filter[1];
        value = hash(value);
        keys.push(db + ":" + name + "_" + property + ":" + value);
      }
      operation = (ref3 = options.operation) != null ? ref3 : 'union';
      multi["s" + operation + "store"].apply(multi, keys);
    } else {
      args.push(db + ":" + name + "_" + identifier);
    }
    if (options.sort != null) {
      args.push('by');
      args.push((db + ":" + name + ":*->") + options.sort);
    }
    ref4 = options.properties;
    for (m = 0, len2 = ref4.length; m < len2; m++) {
      property = ref4[m];
      args.push('get');
      args.push((db + ":" + name + ":*->") + property);
    }
    args.push('alpha');
    args.push((ref5 = options.direction) != null ? ref5 : 'asc');
    args.push((function(_this) {
      return function(err, values) {
        var i, j, record, result;
        if (err) {
          return callback(err);
        }
        if (!values.length) {
          return callback(null, []);
        }
        result = (function() {
          var len3, n, o, ref6, ref7, ref8, results1;
          results1 = [];
          for (i = n = 0, ref6 = values.length, ref7 = options.properties.length; ref7 > 0 ? n < ref6 : n > ref6; i = n += ref7) {
            record = {};
            ref8 = options.properties;
            for (j = o = 0, len3 = ref8.length; o < len3; j = ++o) {
              property = ref8[j];
              record[property] = values[i + j];
            }
            results1.push(this.unserialize(record, options));
          }
          return results1;
        }).call(_this);
        return callback(null, result);
      };
    })(this));
    multi.sort.apply(multi, args);
    if (tempkey) {
      multi.del(tempkey);
    }
    return multi.exec();
  };


  /*
  
  `remove(records, callback)`
  ---------------------------
  Remove one or several records from the database. The function will also 
  handle all the indexes referencing those records.   
  
  `records`           Record object or array of record objects.   
  
  `callback`          Called on success or failure. Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `removed`       Number of removed records.  
  
  Removing a single record:   
  
      Users.remove id, (err, removed) ->
        console.log "#{removed} user removed"
   */

  Records.prototype.remove = function(records, callback) {
    var db, hash, identifier, index, isArray, name, redis, ref, ref1, removed, unique;
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, identifier = ref1.identifier, index = ref1.index, unique = ref1.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    removed = 0;
    return this.get(records, [].concat(Object.keys(unique), Object.keys(index)), function(err, records) {
      var fn, k, len, multi, record;
      if (err) {
        return callback(err);
      }
      multi = redis.multi();
      fn = function(record) {
        var property, recordId, results1, value;
        recordId = record[identifier];
        multi.del(db + ":" + name + ":" + recordId, function(err) {
          return removed++;
        });
        multi.srem(db + ":" + name + "_" + identifier, recordId);
        for (property in unique) {
          multi.hdel(db + ":" + name + "_" + property, record[property]);
        }
        results1 = [];
        for (property in index) {
          value = hash(record[property]);
          results1.push(multi.srem(db + ":" + name + "_" + property + ":" + value, recordId, function(err, count) {
            if (count !== 1) {
              return console.warn('Missing indexed property');
            }
          }));
        }
        return results1;
      };
      for (k = 0, len = records.length; k < len; k++) {
        record = records[k];
        if (record === null) {
          continue;
        }
        fn(record);
      }
      return multi.exec(function(err, results) {
        if (err) {
          return callback(err);
        }
        return callback(null, removed);
      });
    });
  };


  /*
  
  `update(records, [options], callback)` 
  --------------------------------------
  Update one or several records. The records must exists in the database or 
  an error will be returned in the callback. The existence of a record may 
  be discovered through its identifier or the presence of a unique property.   
  
  `records`           Record object or array of record objects.   
  
  `options`           Options properties include:   
  
  *   `validate`      Validate the records.   
  
  `callback`          Called on success or failure. Received parameters are:   
  
  *   `err`           Error object if any.   
  *   `records`       Records with their newly created identifier.   
  
  Records are not validated, it is the responsability of the client program to either
  call `validate` before calling `update` or to passs the `validate` options.   
  
  Updating a single record:   
  
      Users.update
        username: 'my_username'
        age: 28
      , (err, user) -> console.log user
   */

  Records.prototype.update = function(records, options, callback) {
    var db, e, hash, identifier, index, isArray, name, properties, redis, ref, ref1, temporal, unique;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, temporal = ref1.temporal, properties = ref1.properties, identifier = ref1.identifier, unique = ref1.unique, index = ref1.index;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.validate) {
      try {
        this.validate(records, {
          "throw": true,
          skip_required: true
        });
      } catch (error) {
        e = error;
        return callback(e, (isArray ? records : records[0]));
      }
    }
    return this.identify(records, {
      object: true
    }, (function(_this) {
      return function(err, records) {
        var cmdsCheck, cmdsUpdate, fn, k, l, len, len1, multi, property, r, record, recordId, value;
        if (err) {
          return callback(err);
        }
        for (k = 0, len = records.length; k < len; k++) {
          record = records[k];
          if (!record) {
            return callback(new Error('Invalid record'));
          }
        }
        cmdsCheck = [];
        cmdsUpdate = [];
        multi = redis.multi();
        fn = function(record) {
          var len2, m, potentiallyChangedProperties, property, recordId, ref2;
          recordId = record[identifier];
          potentiallyChangedProperties = [];
          ref2 = [].concat(Object.keys(unique), Object.keys(index));
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            property = ref2[m];
            if (typeof record[property] !== 'undefined') {
              potentiallyChangedProperties.push(property);
            }
          }
          if (potentiallyChangedProperties.length) {
            return multi.hmget.apply(multi, [db + ":" + name + ":" + recordId].concat(slice.call(potentiallyChangedProperties), [function(err, values) {
              var len3, n, propertyI, results1, valueNew, valueOld;
              results1 = [];
              for (propertyI = n = 0, len3 = potentiallyChangedProperties.length; n < len3; propertyI = ++n) {
                property = potentiallyChangedProperties[propertyI];
                if (values[propertyI] !== record[property]) {
                  if (properties[property].unique) {
                    cmdsCheck.push(['hexists', db + ":" + name + "_" + property, record[property]]);
                    cmdsUpdate.push(['hdel', db + ":" + name + "_" + property, values[propertyI]]);
                    results1.push(cmdsUpdate.push([
                      'hsetnx', db + ":" + name + "_" + property, record[property], recordId, function(err, success) {
                        if (!success) {
                          return console.warn('Trying to write on existing unique property');
                        }
                      }
                    ]));
                  } else if (properties[property].index) {
                    valueOld = hash(values[propertyI]);
                    valueNew = hash(record[property]);
                    cmdsUpdate.push(['srem', db + ":" + name + "_" + property + ":" + valueOld, recordId]);
                    results1.push(cmdsUpdate.push(['sadd', db + ":" + name + "_" + property + ":" + valueNew, recordId]));
                  } else {
                    results1.push(void 0);
                  }
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }]));
          }
        };
        for (l = 0, len1 = records.length; l < len1; l++) {
          record = records[l];
          recordId = record[identifier];
          if (!recordId) {
            return callback(new Error('Unsaved record'));
          }
          if (((temporal != null ? temporal.modification : void 0) != null) && (record[temporal.modification] == null)) {
            record[temporal.modification] = new Date(Date.now());
          }
          r = {};
          for (property in record) {
            value = record[property];
            if (value != null) {
              r[property] = value;
            } else {
              cmdsUpdate.push(['hdel', db + ":" + name + ":" + recordId, property]);
            }
          }
          _this.serialize(r);
          cmdsUpdate.push(['hmset', db + ":" + name + ":" + recordId, r]);
          fn(record);
        }
        return multi.exec(function(err, values) {
          multi = redis.multi(cmdsCheck);
          return multi.exec(function(err, exists) {
            var exist, len2, m;
            if (err) {
              return callback(err);
            }
            for (m = 0, len2 = exists.length; m < len2; m++) {
              exist = exists[m];
              if (exist !== 0) {
                return callback(new Error('Unique value already exists'));
              }
            }
            multi = redis.multi(cmdsUpdate);
            return multi.exec(function(err, results) {
              if (err) {
                return callback(err);
              }
              return callback(null, isArray ? records : records[0]);
            });
          });
        });
      };
    })(this));
  };

  return Records;

})(Schema);
