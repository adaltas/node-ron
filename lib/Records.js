// Generated by CoffeeScript 1.12.3
var Records, Schema,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

Schema = require('./Schema');

module.exports = Records = (function(superClass) {
  extend(Records, superClass);

  function Records(ron, schema) {
    this.redis = ron.redis;
    Records.__super__.constructor.call(this, ron, schema);
  }

  Records.prototype.all = function(callback) {
    var db, identifier, name, redis, ref;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier;
    return redis.smembers(db + ":" + name + "_" + identifier, (function(_this) {
      return function(err, recordIds) {
        var k, len, multi, recordId;
        multi = redis.multi();
        for (k = 0, len = recordIds.length; k < len; k++) {
          recordId = recordIds[k];
          multi.hgetall(db + ":" + name + ":" + recordId);
        }
        return multi.exec(function(err, records) {
          if (err) {
            return callback(err);
          }
          _this.unserialize(records);
          return callback(null, records);
        });
      };
    })(this));
  };

  Records.prototype.clear = function(callback) {
    var cmds, count, db, hash, identifier, index, indexProperties, indexSort, k, len, multi, name, property, redis, ref, ref1, unique;
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, identifier = ref1.identifier, index = ref1.index, unique = ref1.unique;
    cmds = [];
    count = 0;
    multi = redis.multi();
    indexSort = [];
    indexProperties = Object.keys(index);
    if (indexProperties.length) {
      indexSort.push(db + ":" + name + "_" + identifier);
      for (k = 0, len = indexProperties.length; k < len; k++) {
        property = indexProperties[k];
        indexSort.push('get');
        indexSort.push(db + ":" + name + ":*->" + property);
        cmds.push(['del', db + ":" + name + "_" + property + ":null"]);
      }
      indexSort.push(function(err, values) {
        var i, j, l, ref2, ref3, results1, value;
        if (values.length) {
          results1 = [];
          for (i = l = 0, ref2 = values.length, ref3 = indexProperties.length; ref3 > 0 ? l < ref2 : l > ref2; i = l += ref3) {
            results1.push((function() {
              var len1, m, results2;
              results2 = [];
              for (j = m = 0, len1 = indexProperties.length; m < len1; j = ++m) {
                property = indexProperties[j];
                value = hash(values[i + j]);
                results2.push(cmds.push(['del', db + ":" + name + "_" + property + ":" + value]));
              }
              return results2;
            })());
          }
          return results1;
        }
      });
      multi.sort.apply(multi, indexSort);
    }
    multi.smembers(db + ":" + name + "_" + identifier, function(err, recordIds) {
      var l, len1, recordId, results1;
      if (err) {
        return callback(err);
      }
      if (recordIds == null) {
        recordIds = [];
      }
      count = recordIds.length;
      for (l = 0, len1 = recordIds.length; l < len1; l++) {
        recordId = recordIds[l];
        cmds.push(['del', db + ":" + name + ":" + recordId]);
      }
      cmds.push(['del', db + ":" + name + "_incr"]);
      cmds.push(['del', db + ":" + name + "_" + identifier]);
      for (property in unique) {
        cmds.push(['del', db + ":" + name + "_" + property]);
      }
      results1 = [];
      for (property in index) {
        results1.push(cmds.push(['del', db + ":" + name + "_" + property]));
      }
      return results1;
    });
    return multi.exec(function(err, results) {
      if (err) {
        return callback(err);
      }
      multi = redis.multi(cmds);
      return multi.exec(function(err, results) {
        if (err) {
          return callback(err);
        }
        return callback(null, count);
      });
    });
  };

  Records.prototype.count = function(callback) {
    var db, i, identifier, index, isArray, k, len, multi, name, property, redis, ref, value, values;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, index = ref.index;
    if (arguments.length === 3) {
      property = callback;
      values = arguments[1];
      callback = arguments[2];
      if (!index[property]) {
        return callback(new Error("Property is not indexed"));
      }
      isArray = Array.isArray(values);
      if (!isArray) {
        values = [values];
      }
      multi = redis.multi();
      for (i = k = 0, len = values.length; k < len; i = ++k) {
        value = values[i];
        value = this.hash(value);
        multi.scard(db + ":" + name + "_" + property + ":" + value);
      }
      return multi.exec(function(err, counts) {
        if (err) {
          return callback(err);
        }
        return callback(null, isArray ? counts : counts[0]);
      });
    } else {
      return this.redis.scard(db + ":" + name + "_" + identifier, function(err, count) {
        if (err) {
          return callback(err);
        }
        return callback(null, count);
      });
    }
  };

  Records.prototype.create = function(records, options, callback) {
    var db, e, hash, identifier, index, isArray, name, properties, redis, ref, ref1, temporal, unique;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, temporal = ref1.temporal, properties = ref1.properties, identifier = ref1.identifier, index = ref1.index, unique = ref1.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.validate) {
      try {
        this.validate(records, {
          "throw": true
        });
      } catch (error) {
        e = error;
        return callback(e, (isArray ? records : records[0]));
      }
    }
    return this.exists(records, (function(_this) {
      return function(err, recordIds) {
        var date, k, len, multi, recordId;
        if (err) {
          return callback(err);
        }
        for (k = 0, len = recordIds.length; k < len; k++) {
          recordId = recordIds[k];
          if (recordId != null) {
            return callback(new Error("Record " + recordId + " already exists"));
          }
        }
        multi = redis.multi();
        if (temporal != null) {
          date = new Date(Date.now());
        }
        return _this.id(records, function(err, records) {
          var i, l, len1, property, r, record, value;
          multi = redis.multi();
          for (i = l = 0, len1 = records.length; l < len1; i = ++l) {
            record = records[i];
            if (((temporal != null ? temporal.creation : void 0) != null) && (record[temporal.creation] == null)) {
              record[temporal.creation] = date;
            }
            if (((temporal != null ? temporal.modification : void 0) != null) && (record[temporal.modification] == null)) {
              record[temporal.modification] = date;
            }
            multi.sadd(db + ":" + name + "_" + identifier, record[identifier]);
            for (property in unique) {
              if (record[property]) {
                multi.hset(db + ":" + name + "_" + property, record[property], record[identifier]);
              }
            }
            for (property in index) {
              value = record[property];
              value = hash(value);
              multi.sadd(db + ":" + name + "_" + property + ":" + value, record[identifier]);
            }
            r = {};
            for (property in record) {
              value = record[property];
              if (!properties[property]) {
                continue;
              }
              if (value != null) {
                r[property] = value;
              }
            }
            _this.serialize(r);
            multi.hmset(db + ":" + name + ":" + record[identifier], r);
          }
          return multi.exec(function(err, results) {
            var len2, m, result;
            if (err) {
              return callback(err);
            }
            for (m = 0, len2 = results.length; m < len2; m++) {
              result = results[m];
              if (result[0] === !"0") {
                return callback(new Error('Corrupted user database '));
              }
            }
            _this.unserialize(records, options);
            return callback(null, isArray ? records : records[0]);
          });
        });
      };
    })(this));
  };

  Records.prototype.exists = function(records, callback) {
    var db, identifier, isArray, k, len, multi, name, property, record, recordId, redis, ref, unique;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, unique = ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    multi = redis.multi();
    for (k = 0, len = records.length; k < len; k++) {
      record = records[k];
      if (typeof record === 'object') {
        if (record[identifier] != null) {
          recordId = record[identifier];
          multi.hget(db + ":" + name + ":" + recordId, identifier);
        } else {
          for (property in unique) {
            if (record[property] != null) {
              multi.hget(db + ":" + name + "_" + property, record[property]);
            }
          }
        }
      } else {
        multi.hget(db + ":" + name + ":" + record, identifier);
      }
    }
    return multi.exec((function(_this) {
      return function(err, recordIds) {
        if (err) {
          return callback(err);
        }
        _this.unserialize(recordIds);
        return callback(null, isArray ? recordIds : recordIds[0]);
      };
    })(this));
  };

  Records.prototype.get = function(records, options, callback) {
    var db, identifier, isArray, name, redis, ref;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    if (Array.isArray(options)) {
      options = {
        properties: options
      };
    }
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if ((options.accept_null != null) && !records.some(function(record) {
      return record !== null;
    })) {
      return callback(null, isArray ? records : records[0]);
    }
    return this.identify(records, {
      object: true,
      accept_null: options.accept_null != null
    }, (function(_this) {
      return function(err, records) {
        var cmds, multi;
        if (err) {
          return callback(err);
        }
        cmds = [];
        records.forEach(function(record, i) {
          var recordId, ref1;
          if (record == null) {
            return;
          }
          recordId = record[identifier];
          if (recordId === null) {
            records[i] = null;
          } else if ((ref1 = options.properties) != null ? ref1.length : void 0) {
            options.properties.forEach(function(property) {
              if (!(options.force || record[property])) {
                return cmds.push([
                  'hget', db + ":" + name + ":" + recordId, property, function(err, value) {
                    return record[property] = value;
                  }
                ]);
              }
            });
          } else {
            cmds.push([
              'hgetall', db + ":" + name + ":" + recordId, function(err, values) {
                var property, results1, value;
                results1 = [];
                for (property in values) {
                  value = values[property];
                  results1.push(record[property] = value);
                }
                return results1;
              }
            ]);
          }
          return cmds.push([
            'exists', db + ":" + name + ":" + recordId, function(err, exists) {
              if (!exists) {
                return records[i] = null;
              }
            }
          ]);
        });
        if (cmds.length === 0) {
          return callback(null, isArray ? records : records[0]);
        }
        multi = redis.multi(cmds);
        return multi.exec(function(err, values) {
          var k, len, record, recordsByIds;
          if (err) {
            return callback(err);
          }
          _this.unserialize(records);
          if (options.object) {
            recordsByIds = {};
            for (k = 0, len = records.length; k < len; k++) {
              record = records[k];
              recordsByIds[record[identifier]] = record;
            }
            return callback(null, recordsByIds);
          } else {
            return callback(null, isArray ? records : records[0]);
          }
        });
      };
    })(this));
  };

  Records.prototype.id = function(records, callback) {
    var db, i, identifier, incr, isArray, k, len, name, record, redis, ref, unique;
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, unique = ref.unique;
    if (typeof records === 'number') {
      incr = records;
      isArray = true;
      records = (function() {
        var k, ref1, results1;
        results1 = [];
        for (i = k = 0, ref1 = records; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          results1.push(null);
        }
        return results1;
      })();
    } else {
      isArray = Array.isArray(records);
      if (!isArray) {
        records = [records];
      }
      incr = 0;
      for (k = 0, len = records.length; k < len; k++) {
        record = records[k];
        if (!record[identifier]) {
          incr++;
        }
      }
    }
    return redis.incrby(db + ":" + name + "_incr", incr, (function(_this) {
      return function(err, recordId) {
        var l, len1;
        recordId = recordId - incr;
        if (err) {
          return callback(err);
        }
        for (i = l = 0, len1 = records.length; l < len1; i = ++l) {
          record = records[i];
          if (!record) {
            records[i] = record = {};
          }
          if (!record[identifier]) {
            recordId++;
          }
          if (!record[identifier]) {
            record[identifier] = recordId;
          }
        }
        return callback(null, isArray ? records : records[0]);
      };
    })(this));
  };

  Records.prototype.identify = function(records, options, callback) {
    var cmds, db, err, finalize, i, identifier, isArray, k, len, multi, name, property, record, redis, ref, unique, withUnique;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    redis = this.redis;
    ref = this.data, db = ref.db, name = ref.name, identifier = ref.identifier, unique = ref.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    cmds = [];
    err = null;
    for (i = k = 0, len = records.length; k < len; i = ++k) {
      record = records[i];
      if (typeof record === 'object') {
        if (record == null) {
          if (!options.accept_null) {
            return callback(new Error('Null record'));
          }
        } else if (record[identifier] != null) {

        } else {
          withUnique = false;
          for (property in unique) {
            if (record[property] != null) {
              withUnique = true;
              cmds.push([
                'hget', db + ":" + name + "_" + property, record[property], (function(record) {
                  return function(err, recordId) {
                    return record[identifier] = recordId;
                  };
                })(record)
              ]);
            }
          }
          if (!withUnique) {
            return callback(new Error('Invalid record, got ' + (JSON.stringify(record))));
          }
        }
      } else if (typeof record === 'number' || typeof record === 'string') {
        records[i] = {};
        records[i][identifier] = record;
      } else {
        return callback(new Error('Invalid id, got ' + (JSON.stringify(record))));
      }
    }
    finalize = function() {
      if (!options.object) {
        records = (function() {
          var l, len1, results1;
          results1 = [];
          for (l = 0, len1 = records.length; l < len1; l++) {
            record = records[l];
            if (record != null) {
              results1.push(record[identifier]);
            } else {
              results1.push(record);
            }
          }
          return results1;
        })();
      }
      return callback(null, isArray ? records : records[0]);
    };
    if (cmds.length === 0) {
      return finalize();
    }
    multi = redis.multi(cmds);
    return multi.exec((function(_this) {
      return function(err, results) {
        if (err) {
          return callback(err);
        }
        _this.unserialize(records);
        return finalize();
      };
    })(this));
  };

  Records.prototype.list = function(options, callback) {
    var args, db, filter, hash, identifier, index, k, keys, l, len, len1, len2, m, multi, name, operation, property, redis, ref, ref1, ref2, ref3, ref4, ref5, tempkey, v, value, where;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, identifier = ref1.identifier, index = ref1.index;
    options.properties = options.properties || Object.keys(this.data.properties);
    if (options.identifiers) {
      options.properties = [identifier];
    }
    args = [];
    multi = this.redis.multi();
    if (options.where == null) {
      options.where = {};
    }
    where = [];
    for (property in options) {
      value = options[property];
      if (index[property]) {
        if (Array.isArray(value)) {
          for (k = 0, len = value.length; k < len; k++) {
            v = value[k];
            where.push([property, v]);
          }
        } else {
          where.push([property, value]);
        }
      }
    }
    options.where = Object.keys(options.where).length ? options.where : false;
    if (where.length === 1) {
      ref2 = where[0], property = ref2[0], value = ref2[1];
      value = hash(value);
      args.push(db + ":" + name + "_" + property + ":" + value);
    } else if (where.length > 1) {
      tempkey = "temp:" + ((new Date).getTime()) + (Math.random());
      keys = [];
      keys.push(tempkey);
      args.push(tempkey);
      for (l = 0, len1 = where.length; l < len1; l++) {
        filter = where[l];
        property = filter[0], value = filter[1];
        value = hash(value);
        keys.push(db + ":" + name + "_" + property + ":" + value);
      }
      operation = (ref3 = options.operation) != null ? ref3 : 'union';
      multi["s" + operation + "store"].apply(multi, keys);
    } else {
      args.push(db + ":" + name + "_" + identifier);
    }
    if (options.sort != null) {
      args.push('by');
      args.push((db + ":" + name + ":*->") + options.sort);
    }
    ref4 = options.properties;
    for (m = 0, len2 = ref4.length; m < len2; m++) {
      property = ref4[m];
      args.push('get');
      args.push((db + ":" + name + ":*->") + property);
    }
    args.push('alpha');
    args.push((ref5 = options.direction) != null ? ref5 : 'asc');
    args.push((function(_this) {
      return function(err, values) {
        var i, j, record, result;
        if (err) {
          return callback(err);
        }
        if (!values.length) {
          return callback(null, []);
        }
        result = (function() {
          var len3, n, o, ref6, ref7, ref8, results1;
          results1 = [];
          for (i = n = 0, ref6 = values.length, ref7 = options.properties.length; ref7 > 0 ? n < ref6 : n > ref6; i = n += ref7) {
            record = {};
            ref8 = options.properties;
            for (j = o = 0, len3 = ref8.length; o < len3; j = ++o) {
              property = ref8[j];
              record[property] = values[i + j];
            }
            results1.push(this.unserialize(record, options));
          }
          return results1;
        }).call(_this);
        return callback(null, result);
      };
    })(this));
    multi.sort.apply(multi, args);
    if (tempkey) {
      multi.del(tempkey);
    }
    return multi.exec();
  };

  Records.prototype.remove = function(records, callback) {
    var db, hash, identifier, index, isArray, name, redis, ref, ref1, removed, unique;
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, identifier = ref1.identifier, index = ref1.index, unique = ref1.unique;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    removed = 0;
    return this.get(records, [].concat(Object.keys(unique), Object.keys(index)), function(err, records) {
      var fn, k, len, multi, record;
      if (err) {
        return callback(err);
      }
      multi = redis.multi();
      fn = function(record) {
        var property, recordId, results1, value;
        recordId = record[identifier];
        multi.del(db + ":" + name + ":" + recordId, function(err) {
          return removed++;
        });
        multi.srem(db + ":" + name + "_" + identifier, recordId);
        for (property in unique) {
          multi.hdel(db + ":" + name + "_" + property, record[property]);
        }
        results1 = [];
        for (property in index) {
          value = hash(record[property]);
          results1.push(multi.srem(db + ":" + name + "_" + property + ":" + value, recordId, function(err, count) {
            if (count !== 1) {
              return console.warn('Missing indexed property');
            }
          }));
        }
        return results1;
      };
      for (k = 0, len = records.length; k < len; k++) {
        record = records[k];
        if (record === null) {
          continue;
        }
        fn(record);
      }
      return multi.exec(function(err, results) {
        if (err) {
          return callback(err);
        }
        return callback(null, removed);
      });
    });
  };

  Records.prototype.update = function(records, options, callback) {
    var db, e, hash, identifier, index, isArray, name, properties, redis, ref, ref1, temporal, unique;
    if (arguments.length === 2) {
      callback = options;
      options = {};
    }
    ref = this, redis = ref.redis, hash = ref.hash;
    ref1 = this.data, db = ref1.db, name = ref1.name, temporal = ref1.temporal, properties = ref1.properties, identifier = ref1.identifier, unique = ref1.unique, index = ref1.index;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.validate) {
      try {
        this.validate(records, {
          "throw": true,
          skip_required: true
        });
      } catch (error) {
        e = error;
        return callback(e, (isArray ? records : records[0]));
      }
    }
    return this.identify(records, {
      object: true
    }, (function(_this) {
      return function(err, records) {
        var cmdsCheck, cmdsUpdate, fn, k, l, len, len1, multi, property, r, record, recordId, value;
        if (err) {
          return callback(err);
        }
        for (k = 0, len = records.length; k < len; k++) {
          record = records[k];
          if (!record) {
            return callback(new Error('Invalid record'));
          }
        }
        cmdsCheck = [];
        cmdsUpdate = [];
        multi = redis.multi();
        fn = function(record) {
          var len2, m, potentiallyChangedProperties, property, recordId, ref2;
          recordId = record[identifier];
          potentiallyChangedProperties = [];
          ref2 = [].concat(Object.keys(unique), Object.keys(index));
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            property = ref2[m];
            if (typeof record[property] !== 'undefined') {
              potentiallyChangedProperties.push(property);
            }
          }
          if (potentiallyChangedProperties.length) {
            return multi.hmget.apply(multi, [db + ":" + name + ":" + recordId].concat(slice.call(potentiallyChangedProperties), [function(err, values) {
              var len3, n, propertyI, results1, valueNew, valueOld;
              results1 = [];
              for (propertyI = n = 0, len3 = potentiallyChangedProperties.length; n < len3; propertyI = ++n) {
                property = potentiallyChangedProperties[propertyI];
                if (values[propertyI] !== record[property]) {
                  if (properties[property].unique) {
                    cmdsCheck.push(['hexists', db + ":" + name + "_" + property, record[property]]);
                    cmdsUpdate.push(['hdel', db + ":" + name + "_" + property, values[propertyI]]);
                    results1.push(cmdsUpdate.push([
                      'hsetnx', db + ":" + name + "_" + property, record[property], recordId, function(err, success) {
                        if (!success) {
                          return console.warn('Trying to write on existing unique property');
                        }
                      }
                    ]));
                  } else if (properties[property].index) {
                    valueOld = hash(values[propertyI]);
                    valueNew = hash(record[property]);
                    cmdsUpdate.push(['srem', db + ":" + name + "_" + property + ":" + valueOld, recordId]);
                    results1.push(cmdsUpdate.push(['sadd', db + ":" + name + "_" + property + ":" + valueNew, recordId]));
                  } else {
                    results1.push(void 0);
                  }
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }]));
          }
        };
        for (l = 0, len1 = records.length; l < len1; l++) {
          record = records[l];
          recordId = record[identifier];
          if (!recordId) {
            return callback(new Error('Unsaved record'));
          }
          if (((temporal != null ? temporal.modification : void 0) != null) && (record[temporal.modification] == null)) {
            record[temporal.modification] = new Date(Date.now());
          }
          r = {};
          for (property in record) {
            value = record[property];
            if (value != null) {
              r[property] = value;
            } else {
              cmdsUpdate.push(['hdel', db + ":" + name + ":" + recordId, property]);
            }
          }
          _this.serialize(r);
          cmdsUpdate.push(['hmset', db + ":" + name + ":" + recordId, r]);
          fn(record);
        }
        return multi.exec(function(err, values) {
          multi = redis.multi(cmdsCheck);
          return multi.exec(function(err, exists) {
            var exist, len2, m;
            if (err) {
              return callback(err);
            }
            for (m = 0, len2 = exists.length; m < len2; m++) {
              exist = exists[m];
              if (exist !== 0) {
                return callback(new Error('Unique value already exists'));
              }
            }
            multi = redis.multi(cmdsUpdate);
            return multi.exec(function(err, results) {
              if (err) {
                return callback(err);
              }
              return callback(null, isArray ? records : records[0]);
            });
          });
        });
      };
    })(this));
  };

  return Records;

})(Schema);
