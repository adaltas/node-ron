// Generated by CoffeeScript 1.4.0
var Schema, crypto, isEmail;

crypto = require('crypto');

isEmail = function(email) {
  return /^[a-z0-9,!#\$%&'\*\+\/\=\?\^_`\{\|}~\-]+(\.[a-z0-9,!#\$%&'\*\+\/\=\?\^_`\{\|}~\-]+)*@[a-z0-9\-]+(\.[a-z0-9\-]+)*\.([a-z]{2,})$/.test(email);
};

/*

Schema definition
=================

Schema is a mixin from which `Records` inherits. A schema is defined once 
and must no change. We dont support schema migration at the moment. The `Records`
class inherit all the properties and method of the shema.

`ron`               Reference to the Ron instance   

`options`           Schema definition. Options include:   

*   `name`          Name of the schema.   
*   `properties`    Properties definition, an object or an array.   

Record properties may be defined by the following keys:   

*   `type`          Use to cast the value inside Redis, one of `string`, `int`, `date` or `email`.   
*   `identifier`    Mark this property as the identifier, only one property may be an identifier.   
*   `index`         Create an index on the property.   
*   `unique`        Create a unique index on the property.   
*   `temporal`      Add creation and modification date transparently.   

Define a schema from a configuration object:   

    ron.get 'users', properties: 
      user_id: identifier: true
      username: unique: true
      password: true

Define a schema with a declarative approach:   

    Users = ron.get 'users'
    Users.indentifier 'user_id'
    Users.unique 'username'
    Users.property 'password'

Whichever your style, you can then manipulate your records:   

    users = ron.get 'users'
    users.list (err, users) -> console.log users
*/


module.exports = Schema = (function() {

  function Schema(ron, options) {
    var name, value, _ref;
    this.ron = ron;
    if (typeof options === 'string') {
      options = {
        name: options
      };
    }
    this.data = {
      db: ron.name,
      name: options.name,
      temporal: {},
      properties: {},
      identifier: null,
      index: {},
      unique: {}
    };
    if (options.temporal) {
      this.temporal(options.temporal);
    }
    if (options.properties) {
      _ref = options.properties;
      for (name in _ref) {
        value = _ref[name];
        this.property(name, value);
      }
    }
  }

  /*
  
    `hash(key)`
    -------------
    Utility function used when a redis key is created out of 
    uncontrolled character (like a string instead of an int).
  */


  Schema.prototype.hash = function(key) {
    if (typeof key === 'number') {
      key = "" + key;
    }
    if (key != null) {
      return crypto.createHash('sha1').update(key).digest('hex');
    } else {
      return 'null';
    }
  };

  /*
  
    `identifier(property)`
    ------------------------
    Define a property as an identifier or return the record identifier if
    called without any arguments. An identifier is a property which uniquely 
    define a record. Inside Redis, identifier values are stored in set.
  */


  Schema.prototype.identifier = function(property) {
    if (property != null) {
      if (this.data.properties[property] == null) {
        this.data.properties[property] = {};
      }
      this.data.properties[property].type = 'int';
      this.data.properties[property].identifier = true;
      this.data.identifier = property;
      return this;
    } else {
      return this.data.identifier;
    }
  };

  /*
  
    `index([property])`
    -------------------
    Define a property as indexable or return all index properties. An 
    indexed property allow records access by its property value. For example,
    when using the `list` function, the search can be filtered such as returned
    records match one or multiple values.   
    
    Calling this function without any argument will return an array with all the 
    indexed properties.   
    
    Example:
  
        User.index 'email'
        User.list { filter: { email: 'my@email.com' } }, (err, users) ->
          console.log 'This user has the following accounts:'
          for user in user
            console.log "- #{user.username}"
  */


  Schema.prototype.index = function(property) {
    if (property != null) {
      if (this.data.properties[property] == null) {
        this.data.properties[property] = {};
      }
      this.data.properties[property].index = true;
      this.data.index[property] = true;
      return this;
    } else {
      return Object.keys(this.data.index);
    }
  };

  /*
  
    `property(property, [schema])`
    ------------------------------
    Define a new property or overwrite the definition of an
    existing property. If no schema is provide, return the
    property information.   
    
    Calling this function with only the property argument will return the schema
    information associated with the property.   
    
    It is possible to define a new property without any schema information by 
    providing an empty object.   
    
    Example:   
  
        User.property 'id', identifier: true
        User.property 'username', unique: true
        User.property 'email', { index: true, type: 'email' }
        User.property 'name', {}
  */


  Schema.prototype.property = function(property, schema) {
    if (schema != null) {
      if (schema == null) {
        schema = {};
      }
      schema.name = property;
      this.data.properties[property] = schema;
      if (schema.identifier) {
        this.identifier(property);
      }
      if (schema.index) {
        this.index(property);
      }
      if (schema.unique) {
        this.unique(property);
      }
      return this;
    } else {
      return this.data.properties[property];
    }
  };

  /*
  
    `name()`
    --------
    Return the schema name of the current instance.
  
    Using the function :
        Users = client 'users', properties: username: unique: true
        console.log Users.name() is 'users'
  */


  Schema.prototype.name = function() {
    return this.data.name;
  };

  /*
  
    `serialize(records)`
    --------------------
    Cast record values before their insertion into Redis.
  
    Take a record or an array of records and update values with correct 
    property types.
  */


  Schema.prototype.serialize = function(records) {
    var i, isArray, properties, property, record, value, _i, _len, _ref;
    properties = this.data.properties;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    for (i = _i = 0, _len = records.length; _i < _len; i = ++_i) {
      record = records[i];
      if (record == null) {
        continue;
      }
      if (typeof record === 'object') {
        for (property in record) {
          value = record[property];
          if (((_ref = properties[property]) != null ? _ref.type : void 0) === 'date' && (value != null)) {
            if (typeof value === 'number') {

            } else if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                record[property] = parseInt(value, 10);
              } else {
                record[property] = Date.parse(value);
              }
            } else if (typeof value === 'object' && value instanceof Date) {
              record[property] = value.getTime();
            }
          }
        }
      }
    }
    if (isArray) {
      return records;
    } else {
      return records[0];
    }
  };

  /*
  
    `temporal([options])` 
    ---------------------
    Define or retrieve temporal definition. Marking a schema as 
    temporal will transparently add two new date properties, the 
    date when the record was created (by default "cdate"), and the date 
    when the record was last updated (by default "mdate").
  */


  Schema.prototype.temporal = function(temporal) {
    if (temporal != null) {
      if (temporal === true) {
        temporal = {
          creation: 'cdate',
          modification: 'mdate'
        };
      }
      this.data.temporal = temporal;
      this.property(temporal.creation, {
        type: 'date'
      });
      return this.property(temporal.modification, {
        type: 'date'
      });
    } else {
      return [this.data.temporal.creation, this.data.temporal.modification];
    }
  };

  /*
  
    `unique([property])`
    --------------------
    Define a property as unique or retrieve all the unique properties if no 
    argument is provided. An unique property is similar to a index
    property but the index is stored inside a Redis hash. In addition to being 
    filterable, it could also be used as an identifer to access a record.
    
    Example:
  
        User.unique 'username'
        User.get { username: 'me' }, (err, user) ->
          console.log "This is #{user.username}"
  */


  Schema.prototype.unique = function(property) {
    if (property != null) {
      if (this.data.properties[property] == null) {
        this.data.properties[property] = {};
      }
      this.data.properties[property].unique = true;
      this.data.unique[property] = true;
      return this;
    } else {
      return Object.keys(this.data.unique);
    }
  };

  /*
  
    `unserialize(records, [options])`
    ---------------------------------
    Cast record values to their correct type.   
    
    Take a record or an array of records and update values with correct 
    property types.   
  
    `options`             Options include:   
  
    *   `identifiers`     Return an array of identifiers instead of the record objects.  
    *   `properties`      Array of properties to be returned.  
    *   `milliseconds`    Convert date value to milliseconds timestamps instead of `Date` objects.   
    *   `seconds`         Convert date value to seconds timestamps instead of `Date` objects.
  */


  Schema.prototype.unserialize = function(records, options) {
    var i, identifier, isArray, properties, property, record, value, _i, _len, _ref, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    _ref = this.data, identifier = _ref.identifier, properties = _ref.properties;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    if (options.identifiers) {
      options.properties = [identifier];
    }
    for (i = _i = 0, _len = records.length; _i < _len; i = ++_i) {
      record = records[i];
      if (record == null) {
        continue;
      }
      if (typeof record === 'object') {
        for (property in record) {
          value = record[property];
          if (options.properties && options.properties.indexOf(property) === -1) {
            delete record[property];
            continue;
          }
          if (((_ref1 = properties[property]) != null ? _ref1.type : void 0) === 'int' && (value != null)) {
            record[property] = parseInt(value, 10);
          } else if (((_ref2 = properties[property]) != null ? _ref2.type : void 0) === 'date' && (value != null)) {
            if (/^\d+$/.test(value)) {
              value = parseInt(value, 10);
            } else {
              value = Date.parse(value);
            }
            if (options.milliseconds) {
              record[property] = value;
            } else if (options.seconds) {
              record[property] = Math.round(value / 1000);
            } else {
              record[property] = new Date(value);
            }
          }
        }
        if (options.identifiers) {
          records[i] = record[identifier];
        }
      } else if (typeof record === 'number' || typeof record === 'string') {
        records[i] = parseInt(record);
      }
    }
    if (isArray) {
      return records;
    } else {
      return records[0];
    }
  };

  /*
  
    `validate(records, [options])`
    ------------------------------
    Validate the properties of one or more records. Return a validation 
    object or an array of validation objects depending on the provided 
    records arguments. Keys of a validation object are the name of the invalid 
    properties and their value is a string indicating the type of error.   
  
    `records`             Record object or array of record objects.   
  
    `options`             Options include:   
  
    *   `throw`           Throw errors on first invalid property instead of returning a validation object.   
    *   `skip_required`   Doesn't validate missing properties defined as `required`, usefull for partial update.
  */


  Schema.prototype.validate = function(records, options) {
    var db, isArray, name, properties, property, record, validation, validations, x, _ref;
    if (options == null) {
      options = {};
    }
    _ref = this.data, db = _ref.db, name = _ref.name, properties = _ref.properties;
    isArray = Array.isArray(records);
    if (!isArray) {
      records = [records];
    }
    validations = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = records.length; _i < _len; _i++) {
        record = records[_i];
        validation = {};
        for (x in properties) {
          property = properties[x];
          if (!options.skip_required && property.required && !(record[property.name] != null)) {
            if (options["throw"]) {
              throw new Error("Required property " + property.name);
            } else {
              validation[property.name] = 'required';
            }
          } else if (property.type === 'email' && !isEmail(record[property.name])) {
            if (options["throw"]) {
              throw new Error("Invalid email " + record[property.name]);
            } else {
              validation[property.name] = 'invalid_email';
            }
          }
        }
        _results.push(validation);
      }
      return _results;
    })();
    if (isArray) {
      return validations;
    } else {
      return validations[0];
    }
  };

  return Schema;

})();
